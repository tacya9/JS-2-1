# Документ

----------------
## 1.3 Навигация по DOM-элементам

### 1.3.1
Для страницы:

<html>
<body>
  <div>Пользователи:</div>
  <ul>
    <li>Джон</li>
    <li>Пит</li>
  </ul>
</body>
</html>

Напишите код, чтобы получить в консоль следующие элементы
(с использованием всех свойств из теории)
элемент <div>?
<ul>?
второй <li> (с именем Пит)?

### 1.3.3
Напишите код, который выделит красным цветом все ячейки в таблице по диагонали.

Вам нужно получить из таблицы <table> все диагональные <td> и выделить их, используя код:

//  в переменной td находится DOM-элемент для тега <td>
td.style.backgroundColor = 'red';


## 1.4 Поиск: getElement*, querySelector*

### 1.4.1
Мы имеем следующую верстку:
<input id="textField" type="text" />

Необходимо написать скрипт, который выведет окно для ввода данных (prompt) и то, что введет пользователь должно появиться внутри нашего инпута

### 1.4.2
Мы имеем следующую верстку:
<ul id="todoList">
    <li></li>
    <li></li>
    <li></li>
</ul>

Необходимо написать скрипт, который запросит данные через prompt столько раз, сколько <li> находится в нашем <ul>.
И данные с каждого prompt появятся внутри соответствующего <li>.

### 1.4.3
В самом начале у нас есть самая простая страница:
<html>
<head>
	<title>No page title</title>
</head>
<body>
<script>
	// your code
</script>
</body>
</html>

необходимо написать скрипт, который спросит новое название страницы с помощью prompt и заменит его в title

### 1.4.4
У нас есть простая верстка внутри body:
<h1>My name is</h1>

Необходимо написать скрипт, который закончит эту строчку с таким текстом, который введет пользователь через prompt.
Например пользователь введет "Tania", тогда после выполнения скрипта верстка получится:
<h1>My name is Tania</h1>

А если мы в html файле поменяет только текст в <h1> на "My wife is", то после выполнения скрипта мы получим результат
 с этим новым текстом:
<h1>My wife is Tania</h1>

### 1.4.5
В <body> мы имеем такую верстку (количество спанов в диве может быть разным):
<div>
	<span>1</span> + <span>2</span> + <span>3</span>
</div>
The sum is <span></span>

Добавь необходимые атрибуты в верстке, если нужно, и напиши скрипт, который подсчитает сумму чисел в спанах (внутри
дива) и результат внесет в последний спан после дива.

### 1.4.6
У нас есть враппер div, внутри может находится любое количество <ul> с любым количеством <li>. Необходимо
написать скрипт, который проставит в каждой лишке номера в формате X.Y (X - номер <ul>, Y - номер <li>).
И в конце выведет их количество в отдельных строках. Весь функционал написать в объекте, который будет
инициализироваться dataСollection.init()

Например мы имеем такю верстку:
<div id='lists'>
	<ul>
		<li></li>
		<li></li>
	</ul>
	<ul>
		<li></li>
		<li></li>
		<li></li>
	</ul>
</div>

<div>Total ul - </div>
<div>Total li - </div>

После выполнения скрипта должно быть так:
<div>
	<ul>
		<li>1.1</li>
		<li>1.2</li>
	</ul>
	<ul>
		<li>2.1</li>
		<li>2.2</li>
		<li>2.3</li>
	</ul>
</div>
<div>Total ul - 2</div>
<div>Total li - 5</div>

### 1.4.7
У нас есть такая верстка:
<ol>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
</ol>

необходимо написать скрипт, который будет показывать 2 сообщения:
1) спрашивает: "Введите сообщение для нужного пункта в формате N=Message"
Пользователь вводит например: "2=Second item" и нажимаем OK.
После этого во второй лишке появляется это сообщение - <li>Second item</li>
2) потом появляется подтверждение с вопросом: "Желаете продолжить?"
Если нажимается OK, то все повторяется - появляется опять первое сообщение.
Если нажимается Cancel, то скрипт завершается.

Примечание:
Если пользователь ввел номер несуществующей лишки, то второе сообщение появляется
с другим текстом: "Такого пункта не существует. Желаете продолжить?".
Если пользователь указывает номер не пустой лишки, то она просто перезаписывается с новым сообщением.

### 1.6.1
Напишите код для выбора элемента с атрибутом data-widget-name из документа и прочитайте его значение.

<!DOCTYPE html>
<html>
<body>

  <div data-widget-name="menu">Choose the genre</div>

  <script>
    /* your code */
  </script>
</body>
</html>

### 1.6.2
Сделайте все внешние ссылки оранжевыми, изменяя их свойство style.

Ссылка является внешней, если:

Её href содержит ://
Но не начинается с http://internal.com.
<ul>
  <li><a href="http://google.com">http://google.com</a></li>
  <li><a href="/tutorial">/tutorial.html</a></li>
  <li><a href="local/path">local/path</a></li>
  <li><a href="ftp://ftp.com/my.zip">ftp://ftp.com/my.zip</a></li>
  <li><a href="http://nodejs.org">http://nodejs.org</a></li>
  <li><a href="http://internal.com/test">http://internal.com/test</a></li>
</ul>

### 1.6.3
Мы имеем следующую верстку:
<ul id="colorList">
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>

Необходимо написать скрипт, который запросит цвет фона для каждой лишки через prompt столько раз, сколько <li>
находится в нашем <ul>. В prompt надо вводить только цвет ввиде зарезервированных слов или hex.
После выполнения скрипта мы увидем раскрашенные лишки соответствующим образом.

### 1.6.4
Мы имеем следующую верстку:
<ul id="customList">
    <li>11111</li>
    <li>22222</li>
    <li>33333</li>
</ul>

Необходимо написать скрипт, который запросит стили для каждой лишки через prompt столько раз, сколько <li> находится
в нашем <ul>. В prompt надо вводить стили в таком формате:
[property1]:[value1] [property2]:[value2] [propertyN]:[valueN]
Количество стилей можно вводить любое количество. После выполнения скрипта мы увидем стилизованные лишки
соответствующим образом.

Например пользователь ввел: color:orange fontWeight:bold background:blue lineHeight:50px

И тогда к этой лишке применятся инлайновые стили:
color: orange;
font-weight: bold;
background: blue;
line-height: 50px;

### 1.6.5
Мы имеем следующую верстку:

<div id="original">
<div style="border: 1px solid black;">1</div>
<div style="border: 2px solid red;">2</div>
<div style="border: 3px solid blue;">3</div>
</div>

<div id="copy">
<div>1</div>
<div>2</div>
<div>3</div>
</div>

Необходимо написать скрипт, который скопирует все стили бордеров дивов, которые лежат внутри дива с id="original",
 и применит эти бордеры в таком же порядке к дивам, которые лежат внутри дива с id="copy".
Копирование бордеров должно произойти с увеличением толщины в 5 раз т.е. в копируемые дивы должны получится такие
толщины: 5px, 10px, 15px.
Предполагается, что копируемые инлайн стили содержат только стили с бордерами как в примере.

### 1.6.6
Мы имеем следующие стили (должны быть в head) и верстку:

<style>
td {
  padding: 20px;
  border: 1px solid;
}
</style>

<table>
<tr>
  <td data-bg="blue"></td>
  <td></td>
  <td></td>
  <td data-bg="orange"></td>
</tr>
<tr>
  <td></td>
  <td data-bg="blue"></td>
  <td data-bg="orange"></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td data-bg="orange"></td>
  <td data-bg="blue"></td>
  <td></td>
</tr>
<tr>
  <td data-bg="orange"></td>
  <td></td>
  <td></td>
  <td data-bg="blue"></td>
</tr>
</table>

Необходимо написать скрипт, который пропишет цифры в каждую ячейку в формате X.Y (X - номер строки, Y - номер столбца)
и применит инлайновый бэкграунд только тем ячейкам, которые имеют атрибут data-bg, с соответствующим значением.

### 1.7.1
Создайте функцию clear(elem), которая удаляет всё содержимое из elem.

<ol id="elem">
  <li>Привет</li>
  <li>Мир</li>
</ol>

<script>
  function clear(elem) { /* ваш код */ }

  clear(elem); // очищает список
</script>

### 1.7.2
Напишите интерфейс для создания списка.

Для каждого пункта:

Запрашивайте содержимое пункта у пользователя с помощью prompt.
Создавайте элемент <li> и добавляйте его к <ul>.
Продолжайте до тех пор, пока пользователь не отменит ввод (нажатием клавиши Esc или введя пустую строку).
Все элементы должны создаваться динамически.

Если пользователь вводит HTML-теги, они должны обрабатываться как текст.

### 1.7.3
Напишите функцию createTree, которая создаёт вложенный список ul/li из объекта.
<div id="tree"></div>

Например:

const data = {
"Рыбы": {
"форель": {},
"лосось": {}
},
"Деревья": {
"Огромные": {
"секвойя": {},
"дуб": {}
},
"Цветковые": {
"яблоня": {},
"магнолия": {}
}
}
}

Синтаксис:
const container = document.getElementById('container');
createTree(container, data); // создаёт дерево в контейнере

Выберите один из двух способов решения этой задачи:
Создать строку, а затем присвоить через container.innerHTML.
Создавать узлы через методы DOM.
Если получится – сделайте оба.

P.S. Желательно, чтобы в дереве не было лишних элементов, в частности -– пустых ul /ul на нижнем уровне.

### 1.7.4
Есть дерево, организованное в виде вложенных списков ul/li.

Напишите код, который добавит каждому элементу списка <li> количество вложенных в него элементов. Узлы нижнего уровня,
без детей – пропускайте.
<ul>
    <li>Животные
      <ul>
        <li>Млекопитающие
          <ul>
            <li>Коровы</li>
            <li>Ослы</li>
            <li>Собаки</li>
            <li>Тигры</li>
          </ul>
        </li>
        <li>Другие
          <ul>
            <li>Змеи</li>
            <li>Птицы</li>
            <li>Ящерицы</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Рыбы
      <ul>
        <li>Аквариумные
          <ul>
            <li>Гуппи</li>
            <li>Скалярии</li>
          </ul>
        </li>
        <li>Морские
          <ul>
            <li>Морская форель</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <script>
    // ... ваш код ...
  </script>

Создать строку, а затем присвоить через container.innerHTML.
Создавать узлы через методы DOM.
Если получится – сделайте оба.

P.S. Желательно, чтобы в дереве не было лишних элементов, в частности -– пустых <ul></ul> на нижнем уровне.

### 1.7.5
Напишите функцию createCalendar(elem, year, month).

Вызов функции должен создать календарь для заданного месяца month в году year и вставить его в elem.

Календарь должен быть таблицей, где неделя – это tr, а день – это td. У таблицы должен быть заголовок с названиями
дней недели, каждый день – th, первым днём недели должен быть понедельник.

Например, createCalendar(cal, 2012, 9) сгенерирует в cal следующий календарь:

P.S. В этой задаче достаточно сгенерировать календарь, кликабельным его делать не нужно.

### 1.7.6
Создайте цветные часы как в примере ниже:

Для стилизации используйте HTML/CSS, JavaScript должен только обновлять время в элементах.

### 1.7.7
Доработать задание 1.7.6 - создать объект с методом init, который принимает id контейнера, внутри которого будет
создаваться структура часов вместе с кнопками, которые запускают и останавливают часы.

### 1.7.8
Напишите код для вставки <li>2</li><li>3</li> между этими двумя <li>:
<ul id="ul">
  <li id="one">1</li>
  <li id="two">4</li>
</ul>

### 1.8.1
Напишите функцию showNotification(options), которая создаёт уведомление:
div class="notification" с заданным
содержимым. Уведомление должно автоматически исчезнуть через 1,5 секунды.

showNotification({
top: 10, // 10px от верхней границы окна (по умолчанию 0px)
right: 10, // 10px от правого края окна (по умолчанию 0px)
html: "Hello!", // HTML-уведомление
className: "welcome" // дополнительный класс для div (необязательно)
});.

### 1.9.1
Найти размер прокрутки снизу
важность: 5
Свойство elem.scrollTop содержит размер прокрученной области при отсчёте сверху. А как подсчитать размер прокрутки
снизу (назовём его scrollBottom)?

Напишите соответствующее выражение для произвольного элемента elem.

P.S. Проверьте: если прокрутки нет вообще или элемент полностью прокручен – оно должно давать 0.

### 1.9.2
Напишите код, который возвращает ширину стандартной полосы прокрутки.

Для Windows она обычно колеблется от 12px до 20px. Если браузер не выделяет место под полосу прокрутки (так тоже
бывает, она может быть прозрачной над текстом), тогда значение может быть 0px.

### 1.9.3
Поместите мяч в центр поля
Вычислите их и используйте, чтобы поместить мяч в центр поля:
Элемент должен позиционироваться за счёт JavaScript, а не CSS.
Код должен работать с любым размером мяча (10, 20, 30 пикселей) и любым размером поля без привязки к исходным значениям.
P.S. Да, центрирование можно сделать при помощи чистого CSS, но задача именно на JavaScript. Далее будут другие темы
и более сложные ситуации, когда JavaScript будет уже точно необходим, это – своего рода «разминка».

<div id="field">
	<img src="https://en.js.cx/clipart/ball.svg" id="ball"> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
</div>

### 1.10.1
Необходимо через 2 секунды плавно проскролить всю страницу так, чтобы текст "after 1000px" стал виден вверху страницы.
Структура документа следующая:
<div style="height: 2000px"></div>
<b>after 1000px</b>
<div style="height: 2000px"></div>

### 1.11.1
Найдите координаты точек относительно окна браузера
В ифрейме ниже располагается документ с зелёным «полем».
Используйте JavaScript, чтобы найти координаты углов, обозначенных стрелками.
В документе уже реализована функциональность, когда при клике на любом месте показываются соответствующие координаты.
Ваш код должен при помощи DOM получить четыре пары координат:
верхний левый, внешний угол (это просто).
нижний правый, внешний угол (тоже просто).
верхний левый, внутренний угол (чуть сложнее).
нижний правый, внутренний угол (есть несколько способов, выберите один).
Координаты, вычисленные вами, должны совпадать с теми, которые возвращаются по клику мыши.

P.S. Код должен работать, если у элемента другие размеры или есть рамка, без привязки к конкретным числам.

### 1.11.2
Покажите заметку рядом с элементом
Создайте функцию positionAt(anchor, position, elem), которая позиционирует элемент elem в зависимости от значения
свойства position рядом с элементом anchor.

Аргумент position – строка с одним из 3 значений:

"top" – расположить elem прямо над anchor
"right" – расположить elem непосредственно справа от anchor
"bottom" – расположить elem прямо под anchor
Она используется внутри функции showNote(anchor, position, html), которая уже есть в исходном коде задачи. Она создаёт
и показывает элемент-«заметку» с текстом html на заданной позиции position рядом с элементом anchor.
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Reprehenderit sint atque dolorum fuga ad incidunt
	voluptatum error fugiat animi amet! Odio temporibus nulla id unde quaerat dignissimos enim nisi rem provident
	molestias sit tempore omnis recusandae
	esse sequi officia sapiente.</p>

<blockquote id="blockquote">
	Teacher: Why are you late?
	Student: There was a man who lost a hundred dollar bill.
	Teacher: That's nice. Were you helping him look for it?
	Student: No. I was standing on it.
</blockquote>

<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Reprehenderit sint atque dolorum fuga ad incidunt
	voluptatum error fugiat animi amet! Odio temporibus nulla id unde quaerat dignissimos enim nisi rem provident
	molestias sit tempore omnis recusandae
	esse sequi officia sapiente.</p>

	function showNote(anchor, position, html) {
		const note = document.createElement('div');

		note.className = "note";
		note.innerHTML = html;
		document.body.append(note);

		positionAt(anchor, position, note);
	}

	const blockquote = document.getElementById('blockquote');

	showNote(blockquote, "top", "note above");
	showNote(blockquote, "right", "note at the right");
	showNote(blockquote, "bottom", "note below");

### 1.11.3
Усовершенствуйте решение предыдущего задания Покажите заметку около элемента (абсолютное позиционирование): научите
функцию positionAt(anchor, position, elem) вставлять elem внутрь anchor.

Новые значения для аргумента position:

top-out, right-out, bottom-out – работают так же, как раньше, они вставляют elem сверху/справа/снизу anchor.
top-in, right-in, bottom-in – вставляют elem внутрь anchor: приклеивают его к верхнему/правому/нижнему краю.

### 2.1.1
Добавьте JavaScript к кнопке button, чтобы при нажатии элемент div id="text" исчезал.</br>
<input type="button" id="hider" value="Нажмите, чтобы спрятать текст"/>

<div id="text">Текст</div>

### 2.1.2
Создайте кнопку, которая будет скрывать себя по нажатию.
<input type="button" id="hider" value="Нажмите, чтобы спрятать"/>

### 2.1.3
Пусть мяч перемещается при клике на поле, туда, куда был клик, вот так:
Требования:

Центр мяча должен совпадать с местом нажатия мыши (если это возможно без пересечения краёв поля);
CSS-анимация желательна, но не обязательна;
Мяч ни в коем случае не должен пересекать границы поля;
При прокрутке страницы ничего не должно ломаться;
Заметки:

Код должен уметь работать с различными размерами мяча и поля, не привязываться к каким-либо фиксированным значениям.
Используйте свойства event.clientX/event.clientY для определения координат мыши при клике.

### 2.1.4
Создать меню, которое по нажатию открывается либо закрывается:

P.S. HTML/CSS исходного документа можно и нужно менять.

### 2.1.5
Добавить кнопку закрытия
Есть список сообщений.
При помощи JavaScript для каждого сообщения добавьте в верхний правый угол кнопку закрытия.

### 2.1.6
Создайте «Карусель» –- ленту изображений, которую можно листать влево-вправо нажатием на стрелочки.
В дальнейшем к ней можно будет добавить анимацию, динамическую подгрузку и другие возможности.

P.S. В этой задаче разработка структуры HTML/CSS составляет 90% решения.

### 2.2.1
Необходимо сделать мини карточку продукта, внутри которой находится кнопка "REVIEW".
Когда кликаем по самой карточке, то она выделяется оранжевым цветом, если еще раз кликаем,
то оранжевый цвет снимается (т.е. таким образом мы можем выделить или снять выделение карточки).
Когда кликаем на кнопку "REVIEW", то появляется алерт, в котором написано:
"This is a large popup with detailed product description".
При этом когда мы кликаем по кнопке "REVIEW" сама карточка не должна выделяться.

+-----------------------+
|			             |
|    The product card    |
|			             |
|	     REVIEW           |
|			             |
+-----------------------+

### 2.3.1
Дан список сообщений с кнопками для удаления [x]. Заставьте кнопки работать.

В результате должно работать вот так:

P.S. Используйте делегирование событий. Должен быть лишь один обработчик на элементе-контейнере для всего

### 2.3.2
Создайте дерево, которое по клику на заголовок скрывает-показывает потомков:
Возраст	Имя
Животные
Млекопитающие
Коровы
Ослы
Собаки
Тигры
Другие
Змеи
Птицы
Ящерицы
Рыбы
Аквариумные
Гуппи
Скалярии
Морские
Морская форель

Требования:
Использовать только один обработчик событий (применить делегирование)
Клик вне текста заголовка (на пустом месте) ничего делать не должен.

### 2.3.3
Сделать таблицу сортируемой: при клике на элемент <th> строки таблицы должны сортироваться по соответствующему столбцу.

Каждый элемент <th> имеет атрибут data-type:

<table id="grid">
  <thead>
    <tr>
      <th data-type="number">Возраст</th>
      <th data-type="string">Имя</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>5</td>
      <td>Вася</td>
    </tr>
    <tr>
      <td>10</td>
      <td>Петя</td>
    </tr>
    ...
  </tbody>
</table>
В примере выше первый столбец содержит числа, а второй – строки. Функция сортировки должна это учитывать, ведь числа
 сортируются иначе, чем строки.

Сортировка должна поддерживать только типы "string" и "number".

Возраст	Имя
5	Вася
2	Петя
12	Женя
9	Маша
1	Илья
P.S. Таблица может быть большой, с любым числом строк и столбцов.

### 2.4.1
Сделайте так, чтобы при клике на ссылки внутри элемента id="contents" пользователю выводился вопрос о том,
 действительно ли он хочет покинуть страницу, и если он не хочет, то прерывать переход по ссылке.
Как насчёт того, чтобы прочитать Википедию или посетить W3.org и узнать о современных стандартах?
Детали:

Содержимое #contents может быть загружено динамически и присвоено при помощи innerHTML. Так что найти все ссылки и
поставить на них обработчики нельзя. Используйте делегирование.
Содержимое может иметь вложенные теги, в том числе внутри ссылок, например, <a href=".."><i>...</i></a>.

### 2.4.2
Создайте галерею изображений, в которой основное изображение изменяется при клике на уменьшенный вариант.
P.S. Используйте делегирование.

### 3.1.1
Создайте список, в котором элементы могут быть выделены, как в файловых менеджерах.

При клике на элемент списка выделяется только этот элемент (добавляется класс .selected), отменяется выделение
остальных элементов.
Если клик сделан вместе с Ctrl (Cmd для Mac), то выделение переключается на элементе, но остальные элементы при этом
не изменяются.
Демо:
Кликни на элемент списка, чтобы выделить его.
Кристофер Робин
Винни Пух
Тигра
Кенга
Кролик. Просто Кролик.

P.S. В этом задании все элементы списка содержат только текст. Без вложенных тегов.

P.P.S. Предотвратите стандартное для браузера выделение текста при кликах.

### 3.2.1
Напишите JavaScript код, который показывает подсказку над элементом с атрибутом data-tooltip. Значение атрибута должно
становиться текстом подсказки.

Это похоже на задачу Поведение "подсказка", но здесь элементы с подсказками могут быть вложены друг в друга.
Показываться должна подсказка на самом глубоко вложенном элементе.

Только одна подсказка может быть показана в любой момент времени.

### 3.2.2
Напишите функцию, которая показывает подсказку над элементом только в случае, когда пользователь передвигает мышь на
него, но не через него.

Другими словами, если пользователь подвинул курсор на элементе и остановился – показывать подсказку. А если он просто
быстро провёл курсором по элементу, то не надо ничего показывать. Кому понравится лишнее мелькание?

Технически, мы можем измерять скорость прохода курсора мыши над элементом, и если она низкая, то можно посчитать, что
 пользователь остановил курсор над элементом, и показать ему подсказку. А если скорость высокая, то тогда не показывать.

Создайте для этого универсальный объект new HoverIntent(options).

Его настройки options:

elem – отслеживаемый элемент.
over – функция, вызываемая, при заходе на элемент, считаем что заход – это когда курсор медленно двигается или
остановился над элементом.
out – функция, вызываемая при уходе курсора с элемента (если был заход).
Пример использования такого объекта для показа подсказки:

Если двигать курсор над «часами» быстро, то ничего не произойдёт, а если вы замедлите движение курсора над элементом
или остановите его, то будет показана подсказка.

Обратите внимание: подсказка не должна пропадать (мигать), когда курсор переходит между дочерними элементами часов.

### 3.3.1
Создайте слайдер:

Захватите мышкой синий бегунок и двигайте его.

Важные детали:

Слайдер должен нормально работать при резком движении мыши влево или вправо за пределы полосы. При этом бегунок должен
останавливаться чётко в нужном конце полосы.
При нажатом бегунке мышь может выходить за пределы полосы слайдера, но слайдер пусть всё равно работает (это удобно для
пользователя).

### 3.3.2
В этой задаче вы можете проверить своё понимание сразу нескольких аспектов Drag’n’Drop и DOM.

Сделайте так, чтобы элементы с классом draggable можно было переносить мышкой. Как мяч в этой главе.

Требования к реализации:

Используйте делегирование событий для отслеживания начала перетаскивания: только один обработчик событий mousedown на
 документе.
Если элементы подносят к верхней/нижней границе окна – оно должно прокручиваться вверх/вниз, чтобы позволить дальнейшее
перетаскивание.
Горизонтальная прокрутка отсутствует (чуть-чуть упрощает задачу, её просто добавить).
Элемент при переносе, даже при резких движениях мышкой, не должен даже частично попасть вне окна.


### 3.4.1
Создайте функцию runOnKeys(func, code1, code2, ... code_n), которая запускает func при одновременном нажатии клавиш с
кодами code1, code2, …, code_n.

Например, код ниже выведет alert при одновременном нажатии клавиш "Q" и "W" (в любом регистре, в любой раскладке)

### 3.6.1
Создайте бесконечную страницу. Когда посетитель прокручивает её до конца, она автоматически добавляет текущие время и
дату в текст (чтобы посетитель мог прокрутить ещё).
Пожалуйста, обратите внимание на две важные особенности прокрутки:

Прокрутка «эластична». Можно прокрутить немного дальше начала или конца документа на некоторых браузерах/устройствах
(после появляется пустое место, а затем документ автоматически «отскакивает» к нормальному состоянию).
Прокрутка неточна. Если прокрутить страницу до конца, можно оказаться в 0-50px от реальной нижней границы документа.
Таким образом, «прокрутка до конца» должна означать, что посетитель находится на расстоянии не более 100px от конца
документа.

P.S. В реальной жизни мы можем захотеть показать «больше сообщений» или «больше товаров».

### 3.6.2
Создайте кнопку «наверх», чтобы помочь с прокруткой страницы.

Она должна работать следующим образом:

Пока страница не прокручена вниз хотя бы на высоту окна – кнопка невидима.
Когда страница прокручена вниз больше, чем на высоту окна – появляется стрелка «наверх» в левом верхнем углу. Если
страница прокручивается назад, стрелка исчезает.
Когда нажимается стрелка, страница прокручивается вверх.
Как тут (слева-сверху, прокрутите):

### 3.6.3
Загрузка видимых изображений
важность: 4
Допустим, у нас есть клиент с низкой скоростью соединения, и мы хотим сэкономить его трафик.

Для этого мы решили не показывать изображения сразу, а заменять их на «макеты», как тут:

<img src="placeholder.svg" width="128" height="128" data-src="real.jpg">
То есть, изначально, все изображения – placeholder.svg. Когда страница прокручивается до того положения, где
 пользователь может увидеть изображение – мы меняем src на значение из data-src, и таким образом изображение загружается.

Вот пример в iframe:

Прокрутите его, чтобы увидеть загрузку изображений «по требованию».

Требования:

При загрузке страницы те изображения, которые уже видимы, должны загружаться сразу же, не ожидая прокрутки.
Некоторые изображения могут быть обычными, без data-src. Код не должен касаться их.
Если изображение один раз загрузилось, оно не должно больше перезагружаться при прокрутке.
P.S. Если можете, реализуйте более продвинутое решение, которое будет загружать изображения на одну страницу ниже/после
текущей позиции.

P.P.S. Достаточно обрабатывать вертикальную прокрутку, горизонтальную не требуется.

### 4.1.1
Имеется <select>:

<select id="genres">
  <option value="rock">Рок</option>
  <option value="blues" selected>Блюз</option>
</select>
Используя JavaScript:

Выведите значение и текст выбранного пункта.
Добавьте пункт: <option value="classic">Классика</option>.
Сделайте его выбранным.