# Документ

----------------
## 1.3 Навигация по DOM-элементам

### 1.3.1
Для страницы:

<html>
<body>
  <div>Пользователи:</div>
  <ul>
    <li>Джон</li>
    <li>Пит</li>
  </ul>
</body>
</html>

Напишите код, чтобы получить в консоль следующие элементы
(с использованием всех свойств из теории)
элемент <div>?
<ul>?
второй <li> (с именем Пит)?

### 1.3.3
Напишите код, который выделит красным цветом все ячейки в таблице по диагонали.

Вам нужно получить из таблицы <table> все диагональные <td> и выделить их, используя код:

//  в переменной td находится DOM-элемент для тега <td>
td.style.backgroundColor = 'red';


## 1.4 Поиск: getElement*, querySelector*

### 1.4.1
Мы имеем следующую верстку:
<input id="textField" type="text" />

Необходимо написать скрипт, который выведет окно для ввода данных (prompt) и то, что введет пользователь должно появиться внутри нашего инпута

### 1.4.2
Мы имеем следующую верстку:
<ul id="todoList">
    <li></li>
    <li></li>
    <li></li>
</ul>

Необходимо написать скрипт, который запросит данные через prompt столько раз, сколько <li> находится в нашем <ul>.
И данные с каждого prompt появятся внутри соответствующего <li>.

### 1.4.3
В самом начале у нас есть самая простая страница:
<html>
<head>
	<title>No page title</title>
</head>
<body>
<script>
	// your code
</script>
</body>
</html>

необходимо написать скрипт, который спросит новое название страницы с помощью prompt и заменит его в title

### 1.4.4
У нас есть простая верстка внутри body:
<h1>My name is</h1>

Необходимо написать скрипт, который закончит эту строчку с таким текстом, который введет пользователь через prompt.
Например пользователь введет "Tania", тогда после выполнения скрипта верстка получится:
<h1>My name is Tania</h1>

А если мы в html файле поменяет только текст в <h1> на "My wife is", то после выполнения скрипта мы получим результат
 с этим новым текстом:
<h1>My wife is Tania</h1>

### 1.4.5
В <body> мы имеем такую верстку (количество спанов в диве может быть разным):
<div>
	<span>1</span> + <span>2</span> + <span>3</span>
</div>
The sum is <span></span>

Добавь необходимые атрибуты в верстке, если нужно, и напиши скрипт, который подсчитает сумму чисел в спанах (внутри
дива) и результат внесет в последний спан после дива.

### 1.4.6
У нас есть враппер div, внутри может находится любое количество <ul> с любым количеством <li>. Необходимо
написать скрипт, который проставит в каждой лишке номера в формате X.Y (X - номер <ul>, Y - номер <li>).
И в конце выведет их количество в отдельных строках. Весь функционал написать в объекте, который будет
инициализироваться dataСollection.init()

Например мы имеем такю верстку:
<div id='lists'>
	<ul>
		<li></li>
		<li></li>
	</ul>
	<ul>
		<li></li>
		<li></li>
		<li></li>
	</ul>
</div>

<div>Total ul - </div>
<div>Total li - </div>

После выполнения скрипта должно быть так:
<div>
	<ul>
		<li>1.1</li>
		<li>1.2</li>
	</ul>
	<ul>
		<li>2.1</li>
		<li>2.2</li>
		<li>2.3</li>
	</ul>
</div>
<div>Total ul - 2</div>
<div>Total li - 5</div>

### 1.4.7
У нас есть такая верстка:
<ol>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
</ol>

необходимо написать скрипт, который будет показывать 2 сообщения:
1) спрашивает: "Введите сообщение для нужного пункта в формате N=Message"
Пользователь вводит например: "2=Second item" и нажимаем OK.
После этого во второй лишке появляется это сообщение - <li>Second item</li>
2) потом появляется подтверждение с вопросом: "Желаете продолжить?"
Если нажимается OK, то все повторяется - появляется опять первое сообщение.
Если нажимается Cancel, то скрипт завершается.

Примечание:
Если пользователь ввел номер несуществующей лишки, то второе сообщение появляется
с другим текстом: "Такого пункта не существует. Желаете продолжить?".
Если пользователь указывает номер не пустой лишки, то она просто перезаписывается с новым сообщением.

### 1.6.1
Напишите код для выбора элемента с атрибутом data-widget-name из документа и прочитайте его значение.

<!DOCTYPE html>
<html>
<body>

  <div data-widget-name="menu">Choose the genre</div>

  <script>
    /* your code */
  </script>
</body>
</html>

### 1.6.2
Сделайте все внешние ссылки оранжевыми, изменяя их свойство style.

Ссылка является внешней, если:

Её href содержит ://
Но не начинается с http://internal.com.
<ul>
  <li><a href="http://google.com">http://google.com</a></li>
  <li><a href="/tutorial">/tutorial.html</a></li>
  <li><a href="local/path">local/path</a></li>
  <li><a href="ftp://ftp.com/my.zip">ftp://ftp.com/my.zip</a></li>
  <li><a href="http://nodejs.org">http://nodejs.org</a></li>
  <li><a href="http://internal.com/test">http://internal.com/test</a></li>
</ul>

### 1.6.3
Мы имеем следующую верстку:
<ul id="colorList">
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>

Необходимо написать скрипт, который запросит цвет фона для каждой лишки через prompt столько раз, сколько <li>
находится в нашем <ul>. В prompt надо вводить только цвет ввиде зарезервированных слов или hex.
После выполнения скрипта мы увидем раскрашенные лишки соответствующим образом.

### 1.6.4
Мы имеем следующую верстку:
<ul id="customList">
    <li>11111</li>
    <li>22222</li>
    <li>33333</li>
</ul>

Необходимо написать скрипт, который запросит стили для каждой лишки через prompt столько раз, сколько <li> находится
в нашем <ul>. В prompt надо вводить стили в таком формате:
[property1]:[value1] [property2]:[value2] [propertyN]:[valueN]
Количество стилей можно вводить любое количество. После выполнения скрипта мы увидем стилизованные лишки
соответствующим образом.

Например пользователь ввел: color:orange fontWeight:bold background:blue lineHeight:50px

И тогда к этой лишке применятся инлайновые стили:
color: orange;
font-weight: bold;
background: blue;
line-height: 50px;

### 1.6.5
Мы имеем следующую верстку:

<div id="original">
<div style="border: 1px solid black;">1</div>
<div style="border: 2px solid red;">2</div>
<div style="border: 3px solid blue;">3</div>
</div>

<div id="copy">
<div>1</div>
<div>2</div>
<div>3</div>
</div>

Необходимо написать скрипт, который скопирует все стили бордеров дивов, которые лежат внутри дива с id="original",
 и применит эти бордеры в таком же порядке к дивам, которые лежат внутри дива с id="copy".
Копирование бордеров должно произойти с увеличением толщины в 5 раз т.е. в копируемые дивы должны получится такие
толщины: 5px, 10px, 15px.
Предполагается, что копируемые инлайн стили содержат только стили с бордерами как в примере.

### 1.6.6
Мы имеем следующие стили (должны быть в head) и верстку:

<style>
td {
  padding: 20px;
  border: 1px solid;
}
</style>

<table>
<tr>
  <td data-bg="blue"></td>
  <td></td>
  <td></td>
  <td data-bg="orange"></td>
</tr>
<tr>
  <td></td>
  <td data-bg="blue"></td>
  <td data-bg="orange"></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td data-bg="orange"></td>
  <td data-bg="blue"></td>
  <td></td>
</tr>
<tr>
  <td data-bg="orange"></td>
  <td></td>
  <td></td>
  <td data-bg="blue"></td>
</tr>
</table>

Необходимо написать скрипт, который пропишет цифры в каждую ячейку в формате X.Y (X - номер строки, Y - номер столбца)
и применит инлайновый бэкграунд только тем ячейкам, которые имеют атрибут data-bg, с соответствующим значением.

### 1.7.1
Создайте функцию clear(elem), которая удаляет всё содержимое из elem.

<ol id="elem">
  <li>Привет</li>
  <li>Мир</li>
</ol>

<script>
  function clear(elem) { /* ваш код */ }

  clear(elem); // очищает список
</script>

### 1.7.2
Напишите интерфейс для создания списка.

Для каждого пункта:

Запрашивайте содержимое пункта у пользователя с помощью prompt.
Создавайте элемент <li> и добавляйте его к <ul>.
Продолжайте до тех пор, пока пользователь не отменит ввод (нажатием клавиши Esc или введя пустую строку).
Все элементы должны создаваться динамически.

Если пользователь вводит HTML-теги, они должны обрабатываться как текст.

### 1.7.3
Напишите функцию createTree, которая создаёт вложенный список ul/li из объекта.
<div id="tree"></div>

Например:

const data = {
"Рыбы": {
"форель": {},
"лосось": {}
},
"Деревья": {
"Огромные": {
"секвойя": {},
"дуб": {}
},
"Цветковые": {
"яблоня": {},
"магнолия": {}
}
}
}

Синтаксис:
const container = document.getElementById('container');
createTree(container, data); // создаёт дерево в контейнере

Выберите один из двух способов решения этой задачи:
Создать строку, а затем присвоить через container.innerHTML.
Создавать узлы через методы DOM.
Если получится – сделайте оба.

P.S. Желательно, чтобы в дереве не было лишних элементов, в частности -– пустых ul /ul на нижнем уровне.

### 1.7.4
Есть дерево, организованное в виде вложенных списков ul/li.

Напишите код, который добавит каждому элементу списка <li> количество вложенных в него элементов. Узлы нижнего уровня,
без детей – пропускайте.
<ul>
    <li>Животные
      <ul>
        <li>Млекопитающие
          <ul>
            <li>Коровы</li>
            <li>Ослы</li>
            <li>Собаки</li>
            <li>Тигры</li>
          </ul>
        </li>
        <li>Другие
          <ul>
            <li>Змеи</li>
            <li>Птицы</li>
            <li>Ящерицы</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Рыбы
      <ul>
        <li>Аквариумные
          <ul>
            <li>Гуппи</li>
            <li>Скалярии</li>
          </ul>
        </li>
        <li>Морские
          <ul>
            <li>Морская форель</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <script>
    // ... ваш код ...
  </script>

Создать строку, а затем присвоить через container.innerHTML.
Создавать узлы через методы DOM.
Если получится – сделайте оба.

P.S. Желательно, чтобы в дереве не было лишних элементов, в частности -– пустых <ul></ul> на нижнем уровне.

### 1.7.5
Напишите функцию createCalendar(elem, year, month).

Вызов функции должен создать календарь для заданного месяца month в году year и вставить его в elem.

Календарь должен быть таблицей, где неделя – это <tr>, а день – это <td>. У таблицы должен быть заголовок с названиями
 дней недели, каждый день – <th>, первым днём недели должен быть понедельник.

Например, createCalendar(cal, 2012, 9) сгенерирует в cal следующий календарь:

P.S. В этой задаче достаточно сгенерировать календарь, кликабельным его делать не нужно.

### 1.7.6
Создайте цветные часы как в примере ниже:

Для стилизации используйте HTML/CSS, JavaScript должен только обновлять время в элементах.