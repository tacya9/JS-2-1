# Документ

----------------
## 1.3 Навигация по DOM-элементам

### 1.3.1
Для страницы:

<html>
<body>
  <div>Пользователи:</div>
  <ul>
    <li>Джон</li>
    <li>Пит</li>
  </ul>
</body>
</html>

Напишите код, чтобы получить в консоль следующие элементы
(с использованием всех свойств из теории)
элемент <div>?
<ul>?
второй <li> (с именем Пит)?

### 1.3.3
Напишите код, который выделит красным цветом все ячейки в таблице по диагонали.

Вам нужно получить из таблицы <table> все диагональные <td> и выделить их, используя код:

//  в переменной td находится DOM-элемент для тега <td>
td.style.backgroundColor = 'red';


## 1.4 Поиск: getElement*, querySelector*

### 1.4.1
Мы имеем следующую верстку:
<input id="textField" type="text" />

Необходимо написать скрипт, который выведет окно для ввода данных (prompt) и то, что введет пользователь должно появиться внутри нашего инпута

### 1.4.2
Мы имеем следующую верстку:
<ul id="todoList">
    <li></li>
    <li></li>
    <li></li>
</ul>

Необходимо написать скрипт, который запросит данные через prompt столько раз, сколько <li> находится в нашем <ul>.
И данные с каждого prompt появятся внутри соответствующего <li>.

### 1.4.3
В самом начале у нас есть самая простая страница:
<html>
<head>
	<title>No page title</title>
</head>
<body>
<script>
	// your code
</script>
</body>
</html>

необходимо написать скрипт, который спросит новое название страницы с помощью prompt и заменит его в title

### 1.4.4
У нас есть простая верстка внутри body:
<h1>My name is</h1>

Необходимо написать скрипт, который закончит эту строчку с таким текстом, который введет пользователь через prompt.
Например пользователь введет "Tania", тогда после выполнения скрипта верстка получится:
<h1>My name is Tania</h1>

А если мы в html файле поменяет только текст в <h1> на "My wife is", то после выполнения скрипта мы получим результат
 с этим новым текстом:
<h1>My wife is Tania</h1>

### 1.4.5
В <body> мы имеем такую верстку (количество спанов в диве может быть разным):
<div>
	<span>1</span> + <span>2</span> + <span>3</span>
</div>
The sum is <span></span>

Добавь необходимые атрибуты в верстке, если нужно, и напиши скрипт, который подсчитает сумму чисел в спанах (внутри
дива) и результат внесет в последний спан после дива.

### 1.4.6
У нас есть враппер div, внутри может находится любое количество <ul> с любым количеством <li>. Необходимо
написать скрипт, который проставит в каждой лишке номера в формате X.Y (X - номер <ul>, Y - номер <li>).
И в конце выведет их количество в отдельных строках. Весь функционал написать в объекте, который будет
инициализироваться dataСollection.init()

Например мы имеем такю верстку:
<div id='lists'>
	<ul>
		<li></li>
		<li></li>
	</ul>
	<ul>
		<li></li>
		<li></li>
		<li></li>
	</ul>
</div>

<div>Total ul - </div>
<div>Total li - </div>

После выполнения скрипта должно быть так:
<div>
	<ul>
		<li>1.1</li>
		<li>1.2</li>
	</ul>
	<ul>
		<li>2.1</li>
		<li>2.2</li>
		<li>2.3</li>
	</ul>
</div>
<div>Total ul - 2</div>
<div>Total li - 5</div>

### 1.4.7
У нас есть такая верстка:
<ol>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
	<li></li>
</ol>

необходимо написать скрипт, который будет показывать 2 сообщения:
1) спрашивает: "Введите сообщение для нужного пункта в формате N=Message"
Пользователь вводит например: "2=Second item" и нажимаем OK.
После этого во второй лишке появляется это сообщение - <li>Second item</li>
2) потом появляется подтверждение с вопросом: "Желаете продолжить?"
Если нажимается OK, то все повторяется - появляется опять первое сообщение.
Если нажимается Cancel, то скрипт завершается.

Примечание:
Если пользователь ввел номер несуществующей лишки, то второе сообщение появляется
с другим текстом: "Такого пункта не существует. Желаете продолжить?".
Если пользователь указывает номер не пустой лишки, то она просто перезаписывается с новым сообщением.

### 1.6.1
Напишите код для выбора элемента с атрибутом data-widget-name из документа и прочитайте его значение.

<!DOCTYPE html>
<html>
<body>

  <div data-widget-name="menu">Choose the genre</div>

  <script>
    /* your code */
  </script>
</body>
</html>

### 1.6.2
Сделайте все внешние ссылки оранжевыми, изменяя их свойство style.

Ссылка является внешней, если:

Её href содержит ://
Но не начинается с http://internal.com.
<ul>
  <li><a href="http://google.com">http://google.com</a></li>
  <li><a href="/tutorial">/tutorial.html</a></li>
  <li><a href="local/path">local/path</a></li>
  <li><a href="ftp://ftp.com/my.zip">ftp://ftp.com/my.zip</a></li>
  <li><a href="http://nodejs.org">http://nodejs.org</a></li>
  <li><a href="http://internal.com/test">http://internal.com/test</a></li>
</ul>

### 1.6.3
Мы имеем следующую верстку:
<ul id="colorList">
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>

Необходимо написать скрипт, который запросит цвет фона для каждой лишки через prompt столько раз, сколько <li>
находится в нашем <ul>. В prompt надо вводить только цвет ввиде зарезервированных слов или hex.
После выполнения скрипта мы увидем раскрашенные лишки соответствующим образом.

### 1.6.4
Мы имеем следующую верстку:
<ul id="customList">
    <li>11111</li>
    <li>22222</li>
    <li>33333</li>
</ul>

Необходимо написать скрипт, который запросит стили для каждой лишки через prompt столько раз, сколько <li> находится
в нашем <ul>. В prompt надо вводить стили в таком формате:
[property1]:[value1] [property2]:[value2] [propertyN]:[valueN]
Количество стилей можно вводить любое количество. После выполнения скрипта мы увидем стилизованные лишки
соответствующим образом.

Например пользователь ввел: color:orange fontWeight:bold background:blue lineHeight:50px

И тогда к этой лишке применятся инлайновые стили:
color: orange;
font-weight: bold;
background: blue;
line-height: 50px;

### 1.6.5
Мы имеем следующую верстку:

<div id="original">
<div style="border: 1px solid black;">1</div>
<div style="border: 2px solid red;">2</div>
<div style="border: 3px solid blue;">3</div>
</div>

<div id="copy">
<div>1</div>
<div>2</div>
<div>3</div>
</div>

Необходимо написать скрипт, который скопирует все стили бордеров дивов, которые лежат внутри дива с id="original",
 и применит эти бордеры в таком же порядке к дивам, которые лежат внутри дива с id="copy".
Копирование бордеров должно произойти с увеличением толщины в 5 раз т.е. в копируемые дивы должны получится такие
толщины: 5px, 10px, 15px.
Предполагается, что копируемые инлайн стили содержат только стили с бордерами как в примере.

### 1.6.6
Мы имеем следующие стили (должны быть в head) и верстку:

<style>
td {
  padding: 20px;
  border: 1px solid;
}
</style>

<table>
<tr>
  <td data-bg="blue"></td>
  <td></td>
  <td></td>
  <td data-bg="orange"></td>
</tr>
<tr>
  <td></td>
  <td data-bg="blue"></td>
  <td data-bg="orange"></td>
  <td></td>
</tr>
<tr>
  <td></td>
  <td data-bg="orange"></td>
  <td data-bg="blue"></td>
  <td></td>
</tr>
<tr>
  <td data-bg="orange"></td>
  <td></td>
  <td></td>
  <td data-bg="blue"></td>
</tr>
</table>

Необходимо написать скрипт, который пропишет цифры в каждую ячейку в формате X.Y (X - номер строки, Y - номер столбца)
и применит инлайновый бэкграунд только тем ячейкам, которые имеют атрибут data-bg, с соответствующим значением.

### 1.7.1
Создайте функцию clear(elem), которая удаляет всё содержимое из elem.

<ol id="elem">
  <li>Привет</li>
  <li>Мир</li>
</ol>

<script>
  function clear(elem) { /* ваш код */ }

  clear(elem); // очищает список
</script>

### 1.7.2
Напишите интерфейс для создания списка.

Для каждого пункта:

Запрашивайте содержимое пункта у пользователя с помощью prompt.
Создавайте элемент <li> и добавляйте его к <ul>.
Продолжайте до тех пор, пока пользователь не отменит ввод (нажатием клавиши Esc или введя пустую строку).
Все элементы должны создаваться динамически.

Если пользователь вводит HTML-теги, они должны обрабатываться как текст.

### 1.7.3
Напишите функцию createTree, которая создаёт вложенный список ul/li из объекта.
<div id="tree"></div>

Например:

const data = {
"Рыбы": {
"форель": {},
"лосось": {}
},
"Деревья": {
"Огромные": {
"секвойя": {},
"дуб": {}
},
"Цветковые": {
"яблоня": {},
"магнолия": {}
}
}
}

Синтаксис:
const container = document.getElementById('container');
createTree(container, data); // создаёт дерево в контейнере

Выберите один из двух способов решения этой задачи:
Создать строку, а затем присвоить через container.innerHTML.
Создавать узлы через методы DOM.
Если получится – сделайте оба.

P.S. Желательно, чтобы в дереве не было лишних элементов, в частности -– пустых ul /ul на нижнем уровне.

### 1.7.4
Есть дерево, организованное в виде вложенных списков ul/li.

Напишите код, который добавит каждому элементу списка <li> количество вложенных в него элементов. Узлы нижнего уровня,
без детей – пропускайте.
<ul>
    <li>Животные
      <ul>
        <li>Млекопитающие
          <ul>
            <li>Коровы</li>
            <li>Ослы</li>
            <li>Собаки</li>
            <li>Тигры</li>
          </ul>
        </li>
        <li>Другие
          <ul>
            <li>Змеи</li>
            <li>Птицы</li>
            <li>Ящерицы</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Рыбы
      <ul>
        <li>Аквариумные
          <ul>
            <li>Гуппи</li>
            <li>Скалярии</li>
          </ul>
        </li>
        <li>Морские
          <ul>
            <li>Морская форель</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <script>
    // ... ваш код ...
  </script>

Создать строку, а затем присвоить через container.innerHTML.
Создавать узлы через методы DOM.
Если получится – сделайте оба.

P.S. Желательно, чтобы в дереве не было лишних элементов, в частности -– пустых <ul></ul> на нижнем уровне.

### 1.7.5
Напишите функцию createCalendar(elem, year, month).

Вызов функции должен создать календарь для заданного месяца month в году year и вставить его в elem.

Календарь должен быть таблицей, где неделя – это tr, а день – это td. У таблицы должен быть заголовок с названиями
дней недели, каждый день – th, первым днём недели должен быть понедельник.

Например, createCalendar(cal, 2012, 9) сгенерирует в cal следующий календарь:

P.S. В этой задаче достаточно сгенерировать календарь, кликабельным его делать не нужно.

### 1.7.6
Создайте цветные часы как в примере ниже:

Для стилизации используйте HTML/CSS, JavaScript должен только обновлять время в элементах.

### 1.7.7
Доработать задание 1.7.6 - создать объект с методом init, который принимает id контейнера, внутри которого будет
создаваться структура часов вместе с кнопками, которые запускают и останавливают часы.

### 1.7.8
Напишите код для вставки <li>2</li><li>3</li> между этими двумя <li>:
<ul id="ul">
  <li id="one">1</li>
  <li id="two">4</li>
</ul>

### 1.8.1
Напишите функцию showNotification(options), которая создаёт уведомление:
div class="notification" с заданным
содержимым. Уведомление должно автоматически исчезнуть через 1,5 секунды.

showNotification({
top: 10, // 10px от верхней границы окна (по умолчанию 0px)
right: 10, // 10px от правого края окна (по умолчанию 0px)
html: "Hello!", // HTML-уведомление
className: "welcome" // дополнительный класс для div (необязательно)
});.

### 1.9.1
Найти размер прокрутки снизу
важность: 5
Свойство elem.scrollTop содержит размер прокрученной области при отсчёте сверху. А как подсчитать размер прокрутки
снизу (назовём его scrollBottom)?

Напишите соответствующее выражение для произвольного элемента elem.

P.S. Проверьте: если прокрутки нет вообще или элемент полностью прокручен – оно должно давать 0.

### 1.9.2
Напишите код, который возвращает ширину стандартной полосы прокрутки.

Для Windows она обычно колеблется от 12px до 20px. Если браузер не выделяет место под полосу прокрутки (так тоже
бывает, она может быть прозрачной над текстом), тогда значение может быть 0px.

### 1.9.3
Поместите мяч в центр поля
Вычислите их и используйте, чтобы поместить мяч в центр поля:
Элемент должен позиционироваться за счёт JavaScript, а не CSS.
Код должен работать с любым размером мяча (10, 20, 30 пикселей) и любым размером поля без привязки к исходным значениям.
P.S. Да, центрирование можно сделать при помощи чистого CSS, но задача именно на JavaScript. Далее будут другие темы
и более сложные ситуации, когда JavaScript будет уже точно необходим, это – своего рода «разминка».

<div id="field">
	<img src="https://en.js.cx/clipart/ball.svg" id="ball"> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
	. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
</div>

### 1.10.1
Необходимо через 2 секунды плавно проскролить всю страницу так, чтобы текст "after 1000px" стал виден вверху страницы.
Структура документа следующая:
<div style="height: 2000px"></div>
<b>after 1000px</b>
<div style="height: 2000px"></div>

### 1.11.1
Найдите координаты точек относительно окна браузера
В ифрейме ниже располагается документ с зелёным «полем».
Используйте JavaScript, чтобы найти координаты углов, обозначенных стрелками.
В документе уже реализована функциональность, когда при клике на любом месте показываются соответствующие координаты.
Ваш код должен при помощи DOM получить четыре пары координат:
верхний левый, внешний угол (это просто).
нижний правый, внешний угол (тоже просто).
верхний левый, внутренний угол (чуть сложнее).
нижний правый, внутренний угол (есть несколько способов, выберите один).
Координаты, вычисленные вами, должны совпадать с теми, которые возвращаются по клику мыши.

P.S. Код должен работать, если у элемента другие размеры или есть рамка, без привязки к конкретным числам.

### 1.11.2
Покажите заметку рядом с элементом
Создайте функцию positionAt(anchor, position, elem), которая позиционирует элемент elem в зависимости от значения
свойства position рядом с элементом anchor.

Аргумент position – строка с одним из 3 значений:

"top" – расположить elem прямо над anchor
"right" – расположить elem непосредственно справа от anchor
"bottom" – расположить elem прямо под anchor
Она используется внутри функции showNote(anchor, position, html), которая уже есть в исходном коде задачи. Она создаёт
и показывает элемент-«заметку» с текстом html на заданной позиции position рядом с элементом anchor.
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Reprehenderit sint atque dolorum fuga ad incidunt
	voluptatum error fugiat animi amet! Odio temporibus nulla id unde quaerat dignissimos enim nisi rem provident
	molestias sit tempore omnis recusandae
	esse sequi officia sapiente.</p>

<blockquote id="blockquote">
	Teacher: Why are you late?
	Student: There was a man who lost a hundred dollar bill.
	Teacher: That's nice. Were you helping him look for it?
	Student: No. I was standing on it.
</blockquote>

<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Reprehenderit sint atque dolorum fuga ad incidunt
	voluptatum error fugiat animi amet! Odio temporibus nulla id unde quaerat dignissimos enim nisi rem provident
	molestias sit tempore omnis recusandae
	esse sequi officia sapiente.</p>

	function showNote(anchor, position, html) {
		const note = document.createElement('div');

		note.className = "note";
		note.innerHTML = html;
		document.body.append(note);

		positionAt(anchor, position, note);
	}

	const blockquote = document.getElementById('blockquote');

	showNote(blockquote, "top", "note above");
	showNote(blockquote, "right", "note at the right");
	showNote(blockquote, "bottom", "note below");

### 1.11.3
Усовершенствуйте решение предыдущего задания Покажите заметку около элемента (абсолютное позиционирование): научите
функцию positionAt(anchor, position, elem) вставлять elem внутрь anchor.

Новые значения для аргумента position:

top-out, right-out, bottom-out – работают так же, как раньше, они вставляют elem сверху/справа/снизу anchor.
top-in, right-in, bottom-in – вставляют elem внутрь anchor: приклеивают его к верхнему/правому/нижнему краю.

### 2.1.1
Добавьте JavaScript к кнопке button, чтобы при нажатии элемент div id="text" исчезал.</br>
<input type="button" id="hider" value="Нажмите, чтобы спрятать текст"/>

<div id="text">Текст</div>

### 2.1.2
Создайте кнопку, которая будет скрывать себя по нажатию.
<input type="button" id="hider" value="Нажмите, чтобы спрятать"/>

### 2.1.3
Пусть мяч перемещается при клике на поле, туда, куда был клик, вот так:
Требования:

Центр мяча должен совпадать с местом нажатия мыши (если это возможно без пересечения краёв поля);
CSS-анимация желательна, но не обязательна;
Мяч ни в коем случае не должен пересекать границы поля;
При прокрутке страницы ничего не должно ломаться;
Заметки:

Код должен уметь работать с различными размерами мяча и поля, не привязываться к каким-либо фиксированным значениям.
Используйте свойства event.clientX/event.clientY для определения координат мыши при клике.

### 2.1.4
Создать меню, которое по нажатию открывается либо закрывается:

P.S. HTML/CSS исходного документа можно и нужно менять.

### 2.1.5
Добавить кнопку закрытия
Есть список сообщений.
При помощи JavaScript для каждого сообщения добавьте в верхний правый угол кнопку закрытия.

### 2.1.6
Создайте «Карусель» –- ленту изображений, которую можно листать влево-вправо нажатием на стрелочки.
В дальнейшем к ней можно будет добавить анимацию, динамическую подгрузку и другие возможности.

P.S. В этой задаче разработка структуры HTML/CSS составляет 90% решения.

### 2.2.1
Необходимо сделать мини карточку продукта, внутри которой находится кнопка "REVIEW".
Когда кликаем по самой карточке, то она выделяется оранжевым цветом, если еще раз кликаем,
то оранжевый цвет снимается (т.е. таким образом мы можем выделить или снять выделение карточки).
Когда кликаем на кнопку "REVIEW", то появляется алерт, в котором написано:
"This is a large popup with detailed product description".
При этом когда мы кликаем по кнопке "REVIEW" сама карточка не должна выделяться.

+-----------------------+
|			             |
|    The product card    |
|			             |
|	     REVIEW           |
|			             |
+-----------------------+

### 2.3.1
Дан список сообщений с кнопками для удаления [x]. Заставьте кнопки работать.

В результате должно работать вот так:

P.S. Используйте делегирование событий. Должен быть лишь один обработчик на элементе-контейнере для всего





